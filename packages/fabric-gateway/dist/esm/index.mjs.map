{
  "version": 3,
  "sources": ["../../src/gateway.ts"],
  "sourcesContent": ["import * as grpc from '@grpc/grpc-js';\nimport {connect, Contract, Gateway, Identity, Signer, signers} from '@hyperledger/fabric-gateway';\nimport * as crypto from 'crypto';\nimport {promises as fs} from 'fs';\n\nexport interface FabricOptions {\n  channelName: string\n  chaincodeName: string\n  mspId: string\n  keyPath: string\n  certPath: string\n  tlsCertPath: string\n  peerEndpoint: string\n  peerHostAlias: string\n}\n\nconst utf8Decoder = new TextDecoder();\n\nexport class FabricGateway {\n  private client?: grpc.Client;\n  private signer?: Signer;\n  private gateway?: Gateway;\n  private contract?: Contract;\n  private options: FabricOptions;\n\n  constructor(options: FabricOptions) {\n    this.options = options;\n  }\n\n  displayFabricParameters(): string {\n    return `channelName:       ${this.options.channelName}\\n` +\n    `chaincodeName:     ${this.options.chaincodeName}\\n` +\n    `mspId:             ${this.options.mspId}\\n` +\n    `keyPath:           ${this.options.keyPath}\\n` +\n    `certPath:          ${this.options.certPath}\\n` +\n    `tlsCertPath:       ${this.options.tlsCertPath}\\n` +\n    `peerEndpoint:      ${this.options.peerEndpoint}\\n` +\n    `peerHostAlias:     ${this.options.peerHostAlias}`;\n  }\n\n  private async newSigner(): Promise<Signer> {\n    const keyPath = this.options.keyPath;\n    const privateKeyPem = await fs.readFile(keyPath);\n    const privateKey = crypto.createPrivateKey(privateKeyPem);\n    return signers.newPrivateKeySigner(privateKey);\n  }\n\n  private async newIdentity(): Promise<Identity> {\n    const certPath = this.options.certPath\n    const credentials = await fs.readFile(certPath);\n    const mspId = this.options.mspId;\n    return { mspId, credentials };\n  }\n\n  async newGrpcConnection(): Promise<grpc.Client> {\n    const tlsRootCert = await fs.readFile(this.options.tlsCertPath);\n    const tlsCredentials = grpc.credentials.createSsl(tlsRootCert);\n    return new grpc.Client(this.options.peerEndpoint, tlsCredentials, {\n      'grpc.ssl_target_name_override': this.options.peerHostAlias,\n    });\n  }\n\n  async connect(): Promise<void> {\n    this.client = await this.newGrpcConnection();\n    this.signer = await this.newSigner();\n\n    this.gateway = connect({\n      // @ts-expect-error: its very good as it is\n      client: this.client,\n      identity: await this.newIdentity(),\n      signer: this.signer,\n      // Default timeouts for different gRPC calls\n      evaluateOptions: () => {\n        return { deadline: Date.now() + 10000 }; // 5 seconds\n      },\n      endorseOptions: () => {\n        return { deadline: Date.now() + 15000 }; // 15 seconds\n      },\n      submitOptions: () => {\n        return { deadline: Date.now() + 10000 }; // 5 seconds\n      },\n      commitStatusOptions: () => {\n        return { deadline: Date.now() + 60000 }; // 1 minute\n      },\n    });\n\n    const network = this.gateway.getNetwork(this.options.channelName);\n    this.contract = network.getContract(this.options.chaincodeName);\n  }\n\n  async readAccesses(accessIds: string[]): Promise<any> {\n    if (!this.contract) {\n      throw new Error('contract not defined');\n    }\n\n    console.log('\\n--> Evaluate Transaction: ReadAccesses');\n    const resultBytes = await this.contract.evaluateTransaction('ReadAccesses', JSON.stringify(accessIds));\n    const resultJson = utf8Decoder.decode(resultBytes);\n    return JSON.parse(resultJson);\n  }\n\n  async readRecords(ids: string[]): Promise<any> {\n    if (!this.contract) {\n      throw new Error('contract not defined');\n    }\n\n    console.log('\\n--> Evaluate Transaction: ReadRecords');\n    const resultBytes = await this.contract.evaluateTransaction('ReadRecords', JSON.stringify(ids));\n    const resultJson = utf8Decoder.decode(resultBytes);\n    return JSON.parse(resultJson);\n  }\n\n  async logBadAction(\n    id: string, requestor: string, recordId: string, actionId: string, reason: string): Promise<void> {\n\n    if (!this.contract) {\n      throw new Error('contract not defined');\n    }\n\n    console.log('\\n--> Submit Transaction: LogBadAction');\n    await this.contract.submitTransaction('LogBadAction', id, requestor, recordId, actionId, reason);\n  }\n\n  /*\n  async readRecordTx(resourceId: string, actionId: string): Promise<any> {\n    if (!this.contract) {\n      throw new Error('contract not defined');\n    }\n\n    console.log('\\n--> Submit Transaction: ReadRecordTx');\n    const resultBytes = await this.contract.submitTransaction('ReadRecordTx', resourceId, actionId);\n    const resultJson = utf8Decoder.decode(resultBytes);\n    const result = JSON.parse(resultJson);\n    console.log('*** Result:', result);\n\n    return result;\n  }\n\n  async createRecord(resourceId: string, hash: string, actionId: string): Promise<any> {\n    if (!this.contract) {\n      throw new Error('contract not defined');\n    }\n\n    console.log('\\n--> Submit Transaction: CreateRecord');\n    const resultBytes = await this.contract.submitTransaction('CreateRecord', resourceId, hash, actionId);\n    const resultJson = utf8Decoder.decode(resultBytes);\n    const result = JSON.parse(resultJson);\n    console.log('*** Result:', result);\n\n    return result;\n    //return this.contract.newProposal('CreateEHR', { arguments: [resourceId, hash] })\n  }\n\n  async deleteRecord(resourceId: string, actionId: string): Promise<any> {\n    if (!this.contract) {\n      throw new Error('contract not defined');\n    }\n\n    console.log('\\n--> Submit Transaction: DeleteRecord');\n    const resultBytes = await this.contract.submitTransaction('CreateRecord', resourceId, actionId);\n    const resultJson = utf8Decoder.decode(resultBytes);\n    const result = JSON.parse(resultJson);\n    console.log('*** Result:', result);\n\n    return result;\n  }\n  */\n\n  async close(): Promise<void> {\n    if (this.client && this.gateway) {\n      this.client.close();\n      this.gateway.close();\n    }\n  }\n\n  /*\n  async submitTransaction(unsignedProposal: Proposal): Promise<Status> {\n    if (this.signer === undefined) {\n      throw Error('signer not defined');\n    }\n\n    if (this.gateway === undefined) {\n      throw Error('gateway not defined');\n    }\n\n    const proposalBytes = unsignedProposal.getBytes();\n    const proposalDigest = unsignedProposal.getDigest();\n    const proposalSignature = await this.signer(proposalDigest);\n\n    const signedProposal = this.gateway.newSignedProposal(proposalBytes, proposalSignature);\n\n    // Done by server\n    const unsignedTransaction = await signedProposal.endorse();\n    const transactionBytes = unsignedTransaction.getBytes();\n    const transactionDigest = unsignedTransaction.getDigest();\n    const transactionSignature = await this.signer(transactionDigest)\n    const signedTransaction = this.gateway.newSignedTransaction(transactionBytes, transactionSignature);\n\n    // Done by server\n    const unsignedCommit = await signedTransaction.submit();\n    const commitBytes = unsignedCommit.getBytes();\n    const commitDigest = unsignedCommit.getDigest();\n    const commitSignature = await this.signer(commitDigest)\n    const signedCommit = this.gateway.newSignedCommit(commitBytes, commitSignature);\n\n    const result = signedTransaction.getResult();\n    console.log('*** Result:', result);\n\n    // Done by server\n    const status = await signedCommit.getStatus();\n    console.log('[Status]:', status);\n\n    return status;\n  }\n  */\n}"],
  "mappings": "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",
  "names": ["grpc", "connect", "signers", "crypto", "fs", "utf8Decoder", "FabricGateway", "options", "keyPath", "privateKeyPem", "privateKey", "certPath", "credentials", "tlsRootCert", "tlsCredentials", "network", "accessIds", "resultBytes", "resultJson", "ids", "id", "requestor", "recordId", "actionId", "reason"]
}

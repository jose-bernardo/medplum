{
  "version": 3,
  "sources": ["../../src/gateway.ts"],
  "sourcesContent": ["import * as grpc from '@grpc/grpc-js';\nimport { connect, Contract, Gateway, Identity, Signer, signers } from '@hyperledger/fabric-gateway';\nimport * as crypto from 'crypto';\nimport { promises as fs } from 'fs';\n\nconst utf8Decoder = new TextDecoder();\n\nexport interface FabricOptions {\n  channelName: string\n  chaincodeName: string\n  mspId: string\n  keyPath: string\n  certPath: string\n  tlsCertPath: string\n  peerEndpoint: string\n  peerHostAlias: string\n}\n\nexport class FabricGateway {\n  private client?: grpc.Client;\n  private gateway?: Gateway;\n  private contract?: Contract;\n  private options: FabricOptions;\n\n  constructor(options: FabricOptions) {\n    this.options = options;\n    this.displayFabricParameters();\n  }\n\n  displayFabricParameters(): void {\n    console.log(`channelName:       ${this.options.channelName}`);\n    console.log(`chaincodeName:     ${this.options.chaincodeName}`);\n    console.log(`mspId:             ${this.options.mspId}`);\n    console.log(`keyPath:           ${this.options.keyPath}`);\n    console.log(`certPath:          ${this.options.certPath}`);\n    console.log(`tlsCertPath:       ${this.options.tlsCertPath}`);\n    console.log(`peerEndpoint:      ${this.options.peerEndpoint}`);\n    console.log(`peerHostAlias:     ${this.options.peerHostAlias}`);\n  }\n\n  private async newSigner(): Promise<Signer> {\n    const keyPath = this.options.keyPath;\n    const privateKeyPem = await fs.readFile(keyPath);\n    const privateKey = crypto.createPrivateKey(privateKeyPem);\n    return signers.newPrivateKeySigner(privateKey);\n  }\n\n  private async newIdentity(): Promise<Identity> {\n    const certPath = this.options.certPath\n    const credentials = await fs.readFile(certPath);\n    const mspId = this.options.mspId;\n    return { mspId, credentials };\n  }\n\n  async newGrpcConnection(): Promise<grpc.Client> {\n    const tlsRootCert = await fs.readFile(this.options.tlsCertPath);\n    const tlsCredentials = grpc.credentials.createSsl(tlsRootCert);\n    return new grpc.Client(this.options.peerEndpoint, tlsCredentials, {\n      'grpc.ssl_target_name_override': this.options.peerHostAlias,\n    });\n  }\n\n  async connect(): Promise<void> {\n    this.client = await this.newGrpcConnection();\n\n    this.gateway = connect({\n      client: this.client,\n      identity: await this.newIdentity(),\n      signer: await this.newSigner(),\n      // Default timeouts for different gRPC calls\n      evaluateOptions: () => {\n        return { deadline: Date.now() + 5000 }; // 5 seconds\n      },\n      endorseOptions: () => {\n        return { deadline: Date.now() + 15000 }; // 15 seconds\n      },\n      submitOptions: () => {\n        return { deadline: Date.now() + 5000 }; // 5 seconds\n      },\n      commitStatusOptions: () => {\n        return { deadline: Date.now() + 60000 }; // 1 minute\n      },\n    });\n\n    const network = this.gateway.getNetwork(this.options.channelName);\n    this.contract = network.getContract(this.options.chaincodeName);\n  }\n\n  async readEhrNoLog(resourceId: string): Promise<any> {\n    if (!this.contract) {\n      throw new Error('contract not defined');\n    }\n\n    try {\n      console.log('\\n--> Evaluate Transaction: ReadEHRNoLog');\n      const resultBytes = await this.contract.evaluateTransaction('ReadEHRNoLog', resourceId);\n      const resultJson = utf8Decoder.decode(resultBytes);\n      const result = JSON.parse(resultJson);\n\n      console.log('*** Result:', result);\n\n      return result;\n    } catch (err) {\n      console.log(err);\n      return Promise.reject(err);\n    }\n  }\n\n  async recordUpdateOnLedger(hash: string, resourceId: string): Promise<JSON> {\n    if (!this.contract) {\n      throw new Error('contract not defined');\n    }\n\n    try {\n      console.log('\\n--> Submit Transaction: CreateEHR');\n\n      const resultBytes = await this.contract.submitTransaction(\n        'CreateEHR',\n        resourceId,\n        hash\n      );\n      const resultJson = utf8Decoder.decode(resultBytes);\n      const result = JSON.parse(resultJson);\n\n      console.log('*** Result:', result);\n      console.log('*** Transaction committed successfully');\n\n      return result;\n    } catch (err) {\n      console.log(err);\n      return Promise.reject(err);\n    }\n  }\n\n  async recordDeleteOnLedger(resourceId: string): Promise<any> {\n    if (!this.contract) {\n      throw new Error('contract not defined');\n    }\n\n    console.log('\\n--> Submit Transaction: DeleteEHR');\n\n    const resultBytes = await this.contract.submitTransaction('DeleteEHR', resourceId);\n\n    const resultJson = utf8Decoder.decode(resultBytes);\n    const result = JSON.parse(resultJson);\n    console.log('*** Result:', result);\n    console.log('*** Transaction committed successfully');\n\n    return result;\n  }\n\n  async recordReadOnLedger(resourceId: string): Promise<any> {\n    if (!this.contract) {\n      throw new Error('contract not defined');\n    }\n\n    console.log('\\n--> Submit Transaction: ReadEHR');\n\n    const resultBytes = await this.contract.submitTransaction('ReadEHR', resourceId);\n\n    const resultJson = utf8Decoder.decode(resultBytes);\n    const result = JSON.parse(resultJson);\n    console.log('*** Result:', result);\n    console.log('*** Transaction committed successfully');\n\n    return result;\n  }\n\n  async readActionLogEntry(logEntryId: string): Promise<any> {\n    if (!this.contract) {\n      throw new Error('contract not defined');\n    }\n\n    try {\n      console.log('\\n--> Evaluate Transaction: ReadActionLogEntry');\n\n      const resultBytes = await this.contract.evaluateTransaction('ReadActionLogEntry', logEntryId);\n\n      const resultJson = utf8Decoder.decode(resultBytes);\n      const result = JSON.parse(resultJson);\n      console.log('*** Result:', result);\n\n      return result;\n    } catch (err) {\n      console.log(err);\n      return Promise.reject(err);\n    }\n  }\n\n  async readActionLogEntryByEhrId(ehrId: string): Promise<void> {\n    /* empty */\n    console.log(ehrId);\n  }\n\n  async close(): Promise<void> {\n    if (this.client && this.gateway) {\n      this.client.close();\n      this.gateway.close();\n    }\n  }\n}"],
  "mappings": "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",
  "names": ["grpc", "connect", "signers", "crypto", "fs", "utf8Decoder", "FabricGateway", "options", "keyPath", "privateKeyPem", "privateKey", "certPath", "credentials", "tlsRootCert", "tlsCredentials", "network", "resourceId", "resultBytes", "resultJson", "result", "err", "hash", "logEntryId", "ehrId"]
}
